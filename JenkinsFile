node {
    def WORKSPACE = "/var/lib/jenkins/workspace/todo-management-spring-boot"
    def buildNumber = env.BUILD_NUMBER ?: '0'
    def dockerImageTag = "todo-management-spring-boot:${buildNumber}"

    try {
        // Stage to clone the repository
        stage('Clone Repo') {
            git url: 'https://github.com/rinkuls/todo-management-spring-boot.git',
                credentialsId: 'springdeploy-user',
                branch: 'main'
        }

        // Build the application
        stage('Build') {
            bat "mvn clean install"
        }
/* here main benifit with k8s is we dont need to stop and remove container
           stage('Build docker image') {
                                   dockerImage = docker.build("todo-management-spring-boot:${env.BUILD_NUMBER}")
                            }*/



  /* here main benifit with k8s is we dont need to stop and remove container
          stage('Deploy docker'){
                   echo "Docker Image Tag Name: ${dockerImageTag}"
                   bat  "docker stop db-application || true"
                   bat  " docker rm db-application || true"
                   echo "removed successful"
                   bat  "docker run --name db-application -d -p 8781:8781 todo-management-spring-boot:${env.BUILD_NUMBER}"
                   echo "run successful"
             }*/


        /* can we used directly this stage and skip build and deploy separately but for learning purpose i did this
         stage('Docker Compose Up') {
                bat 'docker --version'
               bat  "docker stop DB-Application || true"
               bat  " docker rm DB-Application || true"
               echo "removed successful"
               bat  "docker-compose -f docker-compose.yml up -d"
               echo "composed successful"
           } */
        // Build Docker image
        stage('Build Docker') {
            echo "Setting Minikube Docker environment for Windows"
            bat '''
            @echo off
            FOR /F "tokens=*" %%i IN ('minikube docker-env --shell cmd') DO @call %%i
            '''

            // Verify if the Docker environment is set correctly
            echo "Verifying Minikube Docker environment..."
            bat 'docker context ls' // Check Docker context in Windows

            // Ensure Minikube Docker daemon is being used
            def dockerEnv = bat(script: 'echo %DOCKER_HOST%', returnStdout: true).trim()
            if (!dockerEnv.contains('tcp://192.168')) {
                error "Minikube Docker environment is not set! Please verify Minikube is running."
            } else {
                echo "Minikube Docker environment verified: ${dockerEnv}"
            }

            // Build the Docker image with the specific tag
            echo "Docker Image Tag Name: ${dockerImageTag}"
            def dockerImage = docker.build(dockerImageTag)

            // Verify the image is built correctly
            echo "Checking available Docker images in Minikube..."
            bat 'docker images' // For Windows to list Docker images
        }

        // Verify if image exists before deploying
        stage('Verify Image') {
            echo 'Verifying if Docker image exists in Minikube...'
            def imageCheck = bat(script: "docker images -q ${dockerImageTag}", returnStdout: true).trim()
            if (!imageCheck) {
                error "Docker image ${dockerImageTag} not found in Minikube!"
            }
        }

        // Deploy to Kubernetes
        stage('kubectl deploy') {
            echo 'Deploying to Kubernetes...'

            // Ensure Minikube context is set for Kubernetes
            bat 'kubectl config use-context minikube'

            // Replace the image tag in the deployment YAML with the correct BUILD_NUMBER
            bat "powershell -Command \"(Get-Content app-deployment.yaml) -replace 'todo-management-spring-boot:latest', 'todo-management-spring-boot:${buildNumber}' | Set-Content app-deployment.yaml\""

            // Apply the deployment and service configuration files
            bat 'kubectl apply -f app-deployment.yaml'
            bat 'kubectl apply -f app-service.yaml'
        }

        echo 'Deployment to Minikube was successful!'
    } catch (e) {
        echo "in catch"
        currentBuild.result = "FAILED"
        echo "Error: ${e.message}"
        notifyBuild(currentBuild.result)
        throw e
    } finally {
        echo "in finally"
    }
}

def notifyBuild(String buildStatus = 'STARTED') {
    buildStatus = buildStatus ?: 'SUCCESSFUL'
    def now = new Date()
    def subject = "${buildStatus}, Job: ${env.JOB_NAME} FRONTEND - Deployment Sequence: [${env.BUILD_NUMBER}] "
    def subject_email = "Spring Boot Deployment"
    def details = """<p>${buildStatus} JOB </p>
    <p>Job: ${env.JOB_NAME} - Deployment Sequence: [${env.BUILD_NUMBER}] - Time: ${now}</p>
    <p>Check console output at "<a href="${env.BUILD_URL}">${env.JOB_NAME}</a>"</p>"""

    // Email notification
    emailext(
        to: "rinkulsharma123@gmail.com",
        subject: subject_email,
        body: details,
    )
}
